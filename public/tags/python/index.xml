<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on Daniel Michaels | Software Developer</title>
    <link>https://danielms.site/tags/python/</link>
    <description>Recent content in python on Daniel Michaels | Software Developer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Thu, 25 Jun 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://danielms.site/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>HTTPX is the new Requests with Async</title>
      <link>https://danielms.site/blog/httpx-is-the-new-requests-with-async/</link>
      <pubDate>Thu, 25 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://danielms.site/blog/httpx-is-the-new-requests-with-async/</guid>
      <description>Long live requests welcome HTTPX  HTTPX is a fully featured HTTP client for Python 3, which provides sync and async APIs, and support for both HTTP/1.1 and HTTP/2.
 Far and away, requests stands as the most notable third party package. It&amp;rsquo;s almost considered part of what makes up python these days. Unfortunately, little forward progress has been made in recent times to incorporate python&amp;rsquo;s async capabilities.
This is where HTTPX is stepping up to the plate.</description>
    </item>
    
    <item>
      <title>Flask Series: Jsonify</title>
      <link>https://danielms.site/blog/flask-jsonify-you-dont-need-it/</link>
      <pubDate>Thu, 14 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://danielms.site/blog/flask-jsonify-you-dont-need-it/</guid>
      <description>Flask jsonify, do I still need it? For a long time, returning JSON in flask required using the flask.jsonify API. However, since this PR Flask will by default call jsonify under the hood on any dictionary it receives on a make_response call.
How does it work When you need to return json in a response, you can simply use a plain python dictionary instead of the jsonify API.
# plain dictionary @app.</description>
    </item>
    
    <item>
      <title>Web Scraping Javascript with Python</title>
      <link>https://danielms.site/blog/web-scraping-javascript-with-python-xhr/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://danielms.site/blog/web-scraping-javascript-with-python-xhr/</guid>
      <description>Scraping Dynamic Pages with Python Web scraping Python is a great tool for web scraping tasks, it is efficient, easy to read and fast. Whenever looking to grab data from a site, the canonical packages are BeautifulSoup and Requests. Unfortunately, when our target site is dynamically rendered, BeautifulSoup can&amp;rsquo;t &amp;ldquo;see&amp;rdquo; those parts leading to a lot of head scratching. The often touted answer to this is Selenium which spins up a browser thereby rendering the JavaScript making it possible to scrape data from it.</description>
    </item>
    
    <item>
      <title>Wagtail embeded YouTube videos</title>
      <link>https://danielms.site/blog/wagtail-embedurl-youtube-tags/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://danielms.site/blog/wagtail-embedurl-youtube-tags/</guid>
      <description>Wagtail Embed Video Wagtail is a brilliant content management service built atop of Django. It comes with all of Django&amp;rsquo;s functionality and Django Rest Framework built in for headless work making life a lot easier.
In all, I really love it, especially its StreamFields. But I did stumble on one component, getting embedded videos to work correctly.
Embedding videos This is harder than I feel it should be and poorly explained by the Wagtail documentation.</description>
    </item>
    
    <item>
      <title>On teaching</title>
      <link>https://danielms.site/blog/on-teaching/</link>
      <pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://danielms.site/blog/on-teaching/</guid>
      <description>on teaching Recently it has befallen upon me to tutor my peers in programming concepts and fundamentals. It struck me that I don&amp;rsquo;t know how to properly impart my knowledge. Where do I start, with strings, or variables. When do I talk about types and equality. Is it better to teach while or for loops first? Classes, OOP, recursion, comprehensions, async! What is important now versus what is the minimum necessary to give them the basics required to go away and learn on their own.</description>
    </item>
    
    <item>
      <title>Python&#39;s bytes and strings</title>
      <link>https://danielms.site/blog/python-bytes-and-strings/</link>
      <pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://danielms.site/blog/python-bytes-and-strings/</guid>
      <description>Python: strings and bytes Python 3 is the new python, and python 2 should be regarded as legacy. But, it is still being used heavily and will likely live beyond its end of life. Recently, a project forced me to use python 2.7 within a Centos environment and I hit some small encoding issues.
Character Sequences In python there are two types that represent sequences of characters:
Python 3
 Bytes: raw 8 bit values Strings: unicode characters  Python 2</description>
    </item>
    
    <item>
      <title>Flask, forms and http requests</title>
      <link>https://danielms.site/blog/flask-forms-and-http-requests/</link>
      <pubDate>Mon, 23 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://danielms.site/blog/flask-forms-and-http-requests/</guid>
      <description>Flask, Forms and HTTP Requests Preface This week I have been building a small webapp that leverage&amp;rsquo;s an external API to populate values in the user pages. And it pains me to say that I spent a silly length of time debugging what was a rather easy problem.
The webapp uses Flask, jinja2 templates and the fuelwatcher API. The issue started when trying to institute a search bar that allows the user to select a series of parameters.</description>
    </item>
    
    <item>
      <title>Uploading to PyPI</title>
      <link>https://danielms.site/blog/uploading-to-pypi/</link>
      <pubDate>Sat, 07 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://danielms.site/blog/uploading-to-pypi/</guid>
      <description>UPDATE 27/01/2019: This area of python and the PyPI is under going rapid development and as such the following may have parts which are no longer in date. In time I will update this post to reflect these changes.
Python Package Index Python has a wonderful community and package ecosystem. It currently has over 130,000 packages for download and a large variety to choose from. To download a python package via the pip command, the package must be uploaded to the Python Package Index, or PyPI.</description>
    </item>
    
    <item>
      <title>Scapy Snippets</title>
      <link>https://danielms.site/blog/scapy-snippets/</link>
      <pubDate>Wed, 28 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://danielms.site/blog/scapy-snippets/</guid>
      <description>How to get RSSI from WLAN packet from scapy.layers.dot11 import RadioTap, Dot11 def get_rssi(packet): if packet.haslayer(RadioTap): return packet.dbm_antsignal caveat: currently only tested on Ralink: RT5370 chipset</description>
    </item>
    
  </channel>
</rss>