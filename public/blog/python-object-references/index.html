<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python Object References | Daniel Michaels</title><meta name=keywords content="ELI5"><meta name=description content="Python Object Reference ELI5  I first learnt about variables through the analogy of &ldquo;variables are boxes&rdquo; and that we assign things to those boxes Turns out, this isn&rsquo;t particularly helpful in objected orientated programming. This post is about how python treats object assignment and some of the hidden gotcha&rsquo;s that can cause unintended errors along the way. Instead of &ldquo;boxes&rdquo; it is better to think of variables as &ldquo;labels&rdquo; that we attach to objects."><meta name=author content="Daniel Michaels"><link rel=canonical href=https://danielms.site/blog/python-object-references/><meta name=google-site-verification content="XYZabc"><link href=https://danielms.site/assets/css/stylesheet.min.08d6f2005b6ce4ed10207916c0411c66e66f2201e3f7a56e8fb2ccbc4a8b259c.css integrity="sha256-CNbyAFts5O0QIHkWwEEcZuZvIgHj96Vuj7LMvEqLJZw=" rel="preload stylesheet" as=style><link rel=icon href=https://danielms.site/extra/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://danielms.site/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://danielms.site/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://danielms.site/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://danielms.site/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.1"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-149607103-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Python Object References"><meta property="og:description" content="Python Object Reference ELI5  I first learnt about variables through the analogy of &ldquo;variables are boxes&rdquo; and that we assign things to those boxes Turns out, this isn&rsquo;t particularly helpful in objected orientated programming. This post is about how python treats object assignment and some of the hidden gotcha&rsquo;s that can cause unintended errors along the way. Instead of &ldquo;boxes&rdquo; it is better to think of variables as &ldquo;labels&rdquo; that we attach to objects."><meta property="og:type" content="article"><meta property="og:url" content="https://danielms.site/blog/python-object-references/"><meta property="og:image" content="https://danielms.site/105"><meta property="article:published_time" content="2018-07-09T00:00:00+00:00"><meta property="article:modified_time" content="2018-07-09T00:00:00+00:00"><meta property="og:site_name" content="Daniel Michaels"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://danielms.site/105"><meta name=twitter:title content="Python Object References"><meta name=twitter:description content="Python Object Reference ELI5  I first learnt about variables through the analogy of &ldquo;variables are boxes&rdquo; and that we assign things to those boxes Turns out, this isn&rsquo;t particularly helpful in objected orientated programming. This post is about how python treats object assignment and some of the hidden gotcha&rsquo;s that can cause unintended errors along the way. Instead of &ldquo;boxes&rdquo; it is better to think of variables as &ldquo;labels&rdquo; that we attach to objects."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python Object References","name":"Python Object References","description":"Python Object Reference ELI5  I first learnt about variables through the analogy of \u0026amp;ldquo;variables are boxes\u0026amp;rdquo; and that we assign things to those boxes Turns out, this …","keywords":["ELI5"],"articleBody":"Python Object Reference ELI5  I first learnt about variables through the analogy of “variables are boxes” and that we assign things to those boxes Turns out, this isn’t particularly helpful in objected orientated programming. This post is about how python treats object assignment and some of the hidden gotcha’s that can cause unintended errors along the way. Instead of “boxes” it is better to think of variables as “labels” that we attach to objects. And, as everything in python is an object its important to remember that all objects have three things; identity, type and values. Values are the only things that change once an object is created, and it values that we often care about, and hence label.\nLabels not boxes Extending the “labels” metaphor a little we look at the assignment of variables.\na = 2 # we label the integer 2 as 'a' b = a # 'a' is now labelled as 'b' c = b # and 'b' is now labelled as 'c' Above we can see that the object 2} is assigned to the variable ‘a’. Each subsequent assignment thereafter is simply a reference to the same object. When viewed through this lense you can start to see how objects have labels. It is not feasible that the 2 can exist in three different boxes rather we visualise 2 having three sticky notes attached to it. If we changed a like this a = 20 then it is just a matter of peeling off the sticky note with a written on it from 2 and attaching it to 20. To further aid in this thinking, always read assignments from right to left. The right side is where the object is created or retrieved and the left is what we bind to it (the label.. Enough you get it already!)\nWhen an object like 2 has many labels we called this aliasing. Aliasing is an important concept to grasp, and to illustrate why we will examine the identity of a, b, and c.\nprint(f'a id: {id(a)}') # original object') # a id: 139886603774600 print(f'b id: {id(b)}') # alias of a') # b id: 139886603774600 print(f'c id: {id(c)}') # copy of a') # c id: 139886603774600 All aliases of a have the same identity which in python is unique integer representing its C memory address. If any change were to be made the identity integer would also change to reflect that.\nWhen is == true? Let’s check out Equality and Identity (and aliases, too)\nAn object’s identity never changes once it has been created. However its values might, and generally this is what we care about more. Python gives us the option to check either like so:\na == b # compares the values a is b # compares the identities Lets extend this using a more complex example using some dictionaries.\nbatman = {'name': 'Bruce Wayne', 'job': 'crime fighter'} bruce = batman print(batman == bruce) # True print(batman is bruce) # True Both batman and bruce are equal in identity, and their values. Suppose we have a vigilante crime fighter out there pretending to be batman, named manbat, does he have the same equality?\nmanbat = {'name': 'Bruce Wayne', 'job': 'crime fighter'} print(batman == manbat) # True print(batman is manbat) # False In this case, both manbat and batman share equal values but not the same identity. manbat is not an alias of bruce or batman, and thus has his own unique identity. This is because we created an entirely new identity albeit with the same values as batman.\nMuch of the time we care mostly about the values an object holds not its identity but you will see is in a lot during conditionals such as:\nif x is None: do something if x is not None: do something else Alias Issues Something I didn’t realise until it came back to haunt me much later is that aliases can have unintended side effects with mutable types. Let’s say we have two lists, the original and its alias. The alias will have items added to it but we want the original untouched for whatever reason.\norig = [10, 20, 30, [100, 200]] new = orig Looks good, we can now make changes to new.\nnew.append('FizzBuzz') print(orig) # [10, 20, 30, [100, 200], 'FizzBuzz'] print(new) # [10, 20, 30, [100, 200], 'FizzBuzz'] After appending to new it becomes apparent that this change has affected both lists. This happens because the alias works two way with mutable types. I think this is really important to know - aliases are not copies!\nCopies If aliases aren’t copies then how do we copy?\norig = [10, 20, 30, [100, 200]] new = list(orig) # dict(x) also works this way print('orig id:', id(orig)) # orig id: 140443406513496 print('new id:', id(new)) # new id: 140443402343535 By using the list() class we successfully create two new objects. Now if we append or remove items from either list it does not propagate through. Except, it does sometimes.\nIn this case we are only making a new copy of the overall object but not any mutable nested types within the copy. So while any changes made within the first layer of the object are contained within the copy, any mutable objects nested more deeply will be aliases.\nConfused, an example.\norig = [10, 20, 30, [100, 200]] new = list(orig) new.append('not nested') print(orig) # [10, 20, 30, [100, 200]] print(new) # [10, 20, 30, [100, 200], 'not nested'] # first layer is not affected as it is a copy, not an alias orig[-1].append('i am aliased to orig') print(orig) # [10, 20, 30, [100, 200, 'i am aliased to a']] print(new) # [10, 20, 30, [100, 200, 'i am aliased to a'], 'not nested'] While the orig and new are independent of each other when making changes to the first layer of abstraction, any mutable types within that are simply aliases of the copies source.\nAnother example to check this out.\n# before we started making alterations to the lists print(id(orig)) # 140443390926984 print(id(new)) # 140443392352593 print(id(orig[-1])) # 140443395483400 print(id(new[-1])) # 140443395483400 Inspecting the identities reveals that only the overall object's were initialised as new objects but the nested types within were bound to the original nested type - an alias!\nThis is something to take into consideration when passing variables around that have nested types. To circumvent this immutable types such as tuples can be used in place.\nPython can do deep copies which will take care of this issue, but it has its own drawbacks. Of which we not be discussed here as this post is already quite long. See Dan Bader's excellent post for more information.\nWrapping Up In python all objects have a type, identity and values. Only the values can change after it is created and knowing a little bit more about how this works can help us prevent unintended bugs.\nNotes:\n assignment does not create copies nested mutable types within shallow copies are aliases equality has two different checks; identity, and values  ","wordCount":"1172","inLanguage":"en","datePublished":"2018-07-09T00:00:00Z","dateModified":"2018-07-09T00:00:00Z","author":{"@type":"Person","name":"Daniel Michaels"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://danielms.site/blog/python-object-references/"},"publisher":{"@type":"Organization","name":"Daniel Michaels","logo":{"@type":"ImageObject","url":"https://danielms.site/extra/favicon.ico"}}}</script></head><body class=single id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://danielms.site accesskey=h>Home</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Python Object References</h1><div class=post-meta>July 9, 2018&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Daniel Michaels</div></header><div class=post-content><h1 id=python-object-reference-eli5>Python Object Reference ELI5<a hidden class=anchor aria-hidden=true href=#python-object-reference-eli5>#</a></h1><hr><p>I first learnt about variables through the analogy of &ldquo;variables are
boxes&rdquo; and that we assign things to those boxes Turns out, this isn&rsquo;t
particularly helpful in objected orientated programming. This post is
about how python treats object assignment and some of the hidden
gotcha&rsquo;s that can cause unintended errors along the way. Instead of
&ldquo;boxes&rdquo; it is better to think of variables as &ldquo;labels&rdquo; that we
attach to objects. And, as everything in python is an object its
important to remember that all objects have three things; identity, type
and values. Values are the only things that change once an object is
created, and it values that we often care about, and hence label.</p><h3 id=labels-not-boxes>Labels not boxes<a hidden class=anchor aria-hidden=true href=#labels-not-boxes>#</a></h3><p>Extending the &ldquo;labels&rdquo; metaphor a little we look at the assignment of
variables.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#75715e># we label the integer 2 as &#39;a&#39;</span>
b <span style=color:#f92672>=</span> a <span style=color:#75715e># &#39;a&#39; is now labelled as &#39;b&#39;</span>
c <span style=color:#f92672>=</span> b <span style=color:#75715e># and &#39;b&#39; is now labelled as &#39;c&#39;</span>
</code></pre></div><p>Above we can see that the object <code>2</code>} is assigned to the
variable &lsquo;a&rsquo;. Each subsequent assignment thereafter is simply a
reference to the same object. When viewed through this lense you can
start to see how objects have labels. It is not feasible that the
<code>2</code> can exist in three different boxes rather we visualise
<code>2</code> having three sticky notes attached to it. If we changed
<code>a</code> like this <code>a = 20</code> then it is just a
matter of peeling off the sticky note with <code>a</code> written on
it from <code>2</code> and attaching it to <code>20</code>. To
further aid in this thinking, always read assignments from right to
left. The right side is where the object is created or retrieved and the
left is what we bind to it (the label.. Enough you get it already!)</p><p>When an object like <code>2</code> has many labels we called this
<em>aliasing</em>. Aliasing is an important concept to grasp, and to illustrate
why we will examine the identity of <code>a</code>, <code>b</code>,
and <code>c</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(f<span style=color:#e6db74>&#39;a id: {id(a)}&#39;</span>) <span style=color:#75715e># original object&#39;)  # a id: 139886603774600</span>
<span style=color:#66d9ef>print</span>(f<span style=color:#e6db74>&#39;b id: {id(b)}&#39;</span>) <span style=color:#75715e># alias of a&#39;)       # b id: 139886603774600</span>
<span style=color:#66d9ef>print</span>(f<span style=color:#e6db74>&#39;c id: {id(c)}&#39;</span>) <span style=color:#75715e># copy of a&#39;)        # c id: 139886603774600</span>
</code></pre></div><p>All aliases of <code>a</code> have the same identity which in python
is unique integer representing its C memory address. If any change were
to be made the identity integer would also change to reflect that.</p><h3 id=when-is--true>When is == true?<a hidden class=anchor aria-hidden=true href=#when-is--true>#</a></h3><p>Let&rsquo;s check out Equality and Identity (and aliases, too)</p><p>An object&rsquo;s identity never changes once it has been created. However
its values might, and generally this is what we care about more. Python
gives us the option to check either like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>a <span style=color:#f92672>==</span> b <span style=color:#75715e># compares the values</span>
a <span style=color:#f92672>is</span> b <span style=color:#75715e># compares the identities</span>
</code></pre></div><p>Lets extend this using a more complex example using some dictionaries.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>batman <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;name&#39;</span>: <span style=color:#e6db74>&#39;Bruce Wayne&#39;</span>, <span style=color:#e6db74>&#39;job&#39;</span>: <span style=color:#e6db74>&#39;crime fighter&#39;</span>}
bruce <span style=color:#f92672>=</span> batman
<span style=color:#66d9ef>print</span>(batman <span style=color:#f92672>==</span> bruce)  <span style=color:#75715e># True</span>
<span style=color:#66d9ef>print</span>(batman <span style=color:#f92672>is</span> bruce)  <span style=color:#75715e># True</span>
</code></pre></div><p>Both <code>batman</code> and <code>bruce</code> are equal in
identity, and their values. Suppose we have a vigilante crime fighter
out there pretending to be <code>batman</code>, named
<code>manbat</code>, does he have the same equality?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>manbat <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;name&#39;</span>: <span style=color:#e6db74>&#39;Bruce Wayne&#39;</span>, <span style=color:#e6db74>&#39;job&#39;</span>: <span style=color:#e6db74>&#39;crime fighter&#39;</span>}
<span style=color:#66d9ef>print</span>(batman <span style=color:#f92672>==</span> manbat) <span style=color:#75715e># True</span>
<span style=color:#66d9ef>print</span>(batman <span style=color:#f92672>is</span> manbat) <span style=color:#75715e># False</span>
</code></pre></div><p>In this case, both <code>manbat</code> and <code>batman</code> share
equal values but not the same identity. <code>manbat</code> is not an
alias of <code>bruce</code> or <code>batman</code>, and thus has his
own unique identity. This is because we created an entirely new identity
albeit with the same values as batman.</p><p>Much of the time we care mostly about the values an object holds not its
identity but you will see <code>is</code> in a lot during conditionals
such as:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>if</span> x <span style=color:#f92672>is</span> None:
  do something
<span style=color:#66d9ef>if</span> x <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> None:
  do something <span style=color:#66d9ef>else</span>
</code></pre></div><h3 id=alias-issues>Alias Issues<a hidden class=anchor aria-hidden=true href=#alias-issues>#</a></h3><p>Something I didn&rsquo;t realise until it came back to haunt me much later is
that aliases can have unintended side effects with mutable types. Let&rsquo;s
say we have two lists, the original and its alias. The alias will have
items added to it but we want the original untouched for whatever
reason.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>orig <span style=color:#f92672>=</span> [<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>30</span>, [<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>]]
new <span style=color:#f92672>=</span> orig
</code></pre></div><p>Looks good, we can now make changes to <code>new</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>new<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;FizzBuzz&#39;</span>)
<span style=color:#66d9ef>print</span>(orig) <span style=color:#75715e># [10, 20, 30, [100, 200], &#39;FizzBuzz&#39;]</span>
<span style=color:#66d9ef>print</span>(new)  <span style=color:#75715e># [10, 20, 30, [100, 200], &#39;FizzBuzz&#39;]</span>
</code></pre></div><p>After appending to <code>new</code> it becomes apparent that this
change has affected both lists. This happens because the alias works two
way with mutable types. I think this is really important to know -
aliases are not copies!</p><h3 id=copies>Copies<a hidden class=anchor aria-hidden=true href=#copies>#</a></h3><p>If aliases aren&rsquo;t copies then how do we copy?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>orig <span style=color:#f92672>=</span> [<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>30</span>, [<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>]]
new <span style=color:#f92672>=</span> list(orig)
<span style=color:#75715e># dict(x) also works this way</span>
<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;orig id:&#39;</span>, id(orig)) <span style=color:#75715e># orig id: 140443406513496</span>
<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#39;new id:&#39;</span>, id(new))   <span style=color:#75715e># new id:  140443402343535</span>
</code></pre></div><p>By using the <code>list()</code> class we successfully create two new
objects. Now if we append or remove items from either list it does not
propagate through. Except, it does sometimes.</p><p>In this case we are only making a new copy of the overall object but not
any <strong>mutable</strong> nested types within the copy. So while any changes made
within the first layer of the object are contained within the copy, any
mutable objects nested more deeply will be aliases.</p><p>Confused, an example.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>orig <span style=color:#f92672>=</span> [<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>30</span>, [<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>]]
new <span style=color:#f92672>=</span> list(orig)
new<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;not nested&#39;</span>)
<span style=color:#66d9ef>print</span>(orig) <span style=color:#75715e># [10, 20, 30, [100, 200]]</span>
<span style=color:#66d9ef>print</span>(new)  <span style=color:#75715e># [10, 20, 30, [100, 200], &#39;not nested&#39;]</span>
<span style=color:#75715e># first layer is not affected as it is a copy, not an alias</span>
orig[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;i am aliased to orig&#39;</span>)
<span style=color:#66d9ef>print</span>(orig) <span style=color:#75715e># [10, 20, 30, [100, 200, &#39;i am aliased to a&#39;]]</span>
<span style=color:#66d9ef>print</span>(new)  <span style=color:#75715e># [10, 20, 30, [100, 200, &#39;i am aliased to a&#39;], &#39;not nested&#39;]</span>
</code></pre></div><p>While the <code>orig</code> and <code>new</code> are independent of
each other when making changes to the first layer of abstraction, any
mutable types within that are simply aliases of the copies source.</p><p>Another example to check this out.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># before we started making alterations to the lists</span>
<span style=color:#66d9ef>print</span>(id(orig))     <span style=color:#75715e># 140443390926984</span>
<span style=color:#66d9ef>print</span>(id(new))      <span style=color:#75715e># 140443392352593</span>
<span style=color:#66d9ef>print</span>(id(orig[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])) <span style=color:#75715e># 140443395483400</span>
<span style=color:#66d9ef>print</span>(id(new[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]))  <span style=color:#75715e># 140443395483400</span>
</code></pre></div><p>Inspecting the identities reveals that only the overall object's were
initialised as new objects but the nested types within were bound to the
original nested type - an alias!</p><p>This is something to take into consideration when passing variables
around that have nested types. To circumvent this immutable types such
as tuples can be used in place.</p><p>Python can do deep copies which will take care of this issue, but it has
its own drawbacks. Of which we not be discussed here as this post is
already quite long. See <a href=https://realpython.com/copying-python-objects/>Dan
Bader's</a> excellent post
for more information.</p><h3 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h3><p>In python all objects have a type, identity and values. Only the values
can change after it is created and knowing a little bit more about how
this works can help us prevent unintended bugs.</p><p><strong>Notes:</strong></p><ul><li>assignment does not create copies</li><li>nested mutable types within shallow copies are aliases</li><li>equality has two different checks; identity, and values</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://danielms.site/tags/eli5>ELI5</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Python Object References on twitter" href="https://twitter.com/intent/tweet/?text=Python%20Object%20References&url=https%3a%2f%2fdanielms.site%2fblog%2fpython-object-references%2f&hashtags=ELI5"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Python Object References on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdanielms.site%2fblog%2fpython-object-references%2f&title=Python%20Object%20References&summary=Python%20Object%20References&source=https%3a%2f%2fdanielms.site%2fblog%2fpython-object-references%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Python Object References on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdanielms.site%2fblog%2fpython-object-references%2f&title=Python%20Object%20References"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Python Object References on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdanielms.site%2fblog%2fpython-object-references%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Python Object References on whatsapp" href="https://api.whatsapp.com/send?text=Python%20Object%20References%20-%20https%3a%2f%2fdanielms.site%2fblog%2fpython-object-references%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Python Object References on telegram" href="https://telegram.me/share/url?text=Python%20Object%20References&url=https%3a%2f%2fdanielms.site%2fblog%2fpython-object-references%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://danielms.site>Daniel Michaels</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://danielms.site/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>